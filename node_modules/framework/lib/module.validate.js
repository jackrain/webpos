/*********************************************************
 * 名称：模块校验工具
 * 日期：2014-12-15
 * 描述：主要用于校验指定实体类或者指定html元素的表单元素
 *       并且提供相关ui样式 可以自行更改样式已针对页面风格
 * 作者：Beven
 * *******************************************************/
var jQuery = require('jquery');
var pathUtil = require('path');

var PATH = "";
var SELECTORS = "input,select,textarea";
var NOTSELECTORS = "input[type=button],input[type=submit],input[type=hidden],input[type=image]";

var ModuleValidate = function () { }
module.exports = ModuleValidate;

//实体类校验工厂
ModuleValidate.prototype.F = require('./module.validator.js');
//通用处理工具
ModuleValidate.prototype.U = require('./util.js');
//类型检测工具
ModuleValidate.prototype.Q = require('./check.js');
//控制流工具
ModuleValidate.prototype.S = require('async');

/*
 * 名称：设置实体类对应的验证配置文件环境目录 例如：我们这里应该是 xxx/business/validates 
 * 参数(path)：验证配置文件目录路径
 */
ModuleValidate.SetEnviroment = function (path) {
    PATH = path;
}
/*
 * 名称：校验传入实体类实例
 * 参数(model)：待校验数据 例如:{name:1,age:2}
 * 参数(name) ：实例对应实体类名称 主要用于寻找对应的校验配置文件 例如: c_vip 那么默认会找c_vip.validate.js
 * 参数(callBack)：验证回调函数 默认可以不填写，主要用于当验证中包含 异步验证器的话，那么要获取最终验证结果，必须使用回调函数 callback(result)
 *                 如果不包含异步校验器 则可以直接获取当前方法的返回值{valid:结果,message:消息}
 */
ModuleValidate.prototype.ValidateModel = function (model, name, callBack) {
    var keys = this.U.GetKeys(model);
    var context = { r: this.GetEmptyResult(true), cfgRules: GetObjectRules(name), model: model };
    this.S.eachSeries(keys, this.GetCall(this.IteratorValidateAttribute, context), function (err) { if (typeof (callBack) == 'function') { callBack(context.r); } });
    return context.r;
}
/*
 * 名称：验证指定表单
 * 参数()：
 */
ModuleValidate.prototype.ValidateForm = function (selector, name, callBack) {
   //可以讲表单序列化 然后调用ValidateModel
}
/*
 * 名称：注册表单验证 主要是将一个指定html元素作为一个容器 添加一些验证事件 例如：失去焦点，与获取焦点默认会去校验容器总的表单
 * 参数(selector)：表单元素选择器
 * 参数(name)： 当前容器对应的实体名称 主要用于寻找对应的校验配置文件 例如: c_vip 那么默认会找c_vip.validate.js
 */
ModuleValidate.prototype.RegistValidateForm = function (selector, name) {
    var container = jQuery(selector);
    if (container.length <= 0) {
        return;
    }
    var cfgRules = GetObjectRules(name);
    var self = this;
    //当容器中表单失去焦点
    container.bind('blur', function (ev) {
        var target = self.IsForms((ev.srcElement || ev.target));
        if (target) {
            var name = target.attr("name");
            var attrRules = cfgRules[name];
            var context = { r: self.GetEmptyResult(true) };
            var r = self.ValidateAttribute(target.val(), attrRules, target, function () { self.OnFormsBlurAndValidated(target, r); }, context);
        }
    });
    //当容器中表单获取焦点
    container.bind('focus', function (ev) {
        var target = self.IsForms((ev.srcElement || ev.target));
        if (target) {
            self.OnFormsFocus(target);
        }
    });
}
/*
 * 名称：表单元素获取焦点事件
 * 参数(target)： 触发获取焦点的表单元素 为jquery包装对象 即$(element);
 */
ModuleValidate.prototype.OnFormsFocus = function (target) {
    target.removeClass("invalidtion").addClass("focusing");
}
/*
 * 名称：表单元素市区焦点并且验证完毕
 * 参数(target)： 触发失去焦点的表单元素 为jquery包装对象 即$(element);
 * 参数(r)：验证结果 {valid:true/false,message:xxxx}
 */
ModuleValidate.prototype.OnFormsBlurAndValidated = function (target, r) {
    if (!r.valid) {
        target.removeClass("focusing").removeClass("availability").addClass("invalidtion");
    } else {
        target.removeClass("focusing").removeClass("invalidtion").addClass("availability");
    }
}
/*
 * 名称：判断指定元素是否符合表单元素
 * 参数(e)：判断传入的原生态dom元素是否为指定的表单控件类型
 */
ModuleValidate.prototype.IsForms = function (e) {
    var target = jQuery(e);
    if (target.is(SELECTORS) && target.not(NOTSELECTORS)) {
        return target;
    } else {
        return null;
    }
}
/*
 * 名称：根据传入属性验证配置验证属性值
 * 参数(v)：属性对应的 值
 * 参数(attrRules)：属性验证规则列表 例如:{required:true,range:[1,5]....}
 * 参数(element)：如果是表单验证的话，那么默认会传递一个对应的dom元素
 * 参数(callBack)：验证下一个属性的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.ValidateAttribute = function (v, attrRules, element, callBack, context) {
    var r = null;
    if (attrRules) {
        r = context.r;
        //1.无论如何首先校验非空验证
        attrRules.required && (r = context.r = this.ValidateRule(v, attrRules.required, 'required', element, null, context));
        //2.校验其他规则
        r.valid && this.ValidateRules(v, attrRules, 'required', element, callBack, context);
    }
    //如果不需要验证或者 非空校验结果为false
    if (r == null || !r.valid) {
        callBack(r);
    }
}
/*
 * 名称：根据传入的规则键值列表进行批量验证
 * 参数(v)：属性对应的 值
 * 参数(rules)：属性验证规则列表 例如:{required:true,range:[1,5]....}
 * 参数(ignores)：要忽略的验证器数组 例如:['required','range']
 * 参数(element)：如果是表单验证的话，那么默认会传递一个对应的dom元素
 * 参数(callBack)：验证下一个属性的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.ValidateRules = function (v, rules, ignores, element, callBack, context) {
    ignores = this.U.EnsureArray(ignores);
    if (this.Q.isObject(rules)) {
        var keys = this.U.GetKeys(rules);
        context.rules = rules;
        context.element = element;
        context.ignores = ignores;
        this.S.eachSeries(keys, this.GetCall(this.IteratorValidateRule, v, context), this.GetCall(this.SeriesFinal, callBack, context));
    } else {
        callBack();
    }
}
/*
 * 名称：根据传入指定规则验证指定属性值
 * 参数(v)：属性对应的 值
 * 参数(rule)：验证器配置对象
 * 参数(name)：当前配置对应的验证器名称 例如'required'那么会在验证工厂中找到已经注册的验证器
 * 参数(element)：如果是表单验证的话，那么默认会传递一个对应的dom元素
 * 参数(callBack)：验证下一个验证器的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.ValidateRule = function (v, rule, name, element, callback, rContext) {
    var validator = this.F.GetValidator(name);
    var paras = [];
    if (!this.Q.isObject(rule)) {
        paras.push.apply(paras, this.U.EnsureArray(rule));
        rule = {};
    }
    var context = { rule: rule, paras: paras };
    return validator.Validate(v, element, context, this.GetCall(this.ValidateRuleFinal, callback, rContext));
}
/*
 * 名称：控制流函数：校验指定规则完毕
 * 参数(r)：验证结果
 * 参数(callBack)：验证下一个验证器的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.ValidateRuleFinal = function (r, callback, context) {
    context.r = r;
    if (this.Q.isFunction(callback)) {
        if (!r.valid) {
            callback(r);
        } else {
            callback();
        }
    }
}
/*
 * 名称：控制流函数:串行验证指定属性规则的实现函数
 * 参数(i)：属性名称
 * 参数(callBack)：验证下一个属性的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.IteratorValidateAttribute = function (i, callBack, context) {
    var cfgRules = context.cfgRules;
    var model = context.model;
    this.ValidateAttribute(model[i], cfgRules[i], null, callBack, context);
}
/*
 * 名称：控制流函数：验证整个实体类实例完毕后的最终回调函数 
 * 参数(err)：验证错误信息
 * 参数(fn)：验证完毕后的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.SeriesFinal = function (err, fn, context) {
    if (!context.r.valid) {
        fn(context);
    } else {
        fn();
    }
}
/*
 * 名称：控制流函数:串行校验指定规则的实现函数
 * 参数(i)：属性名称
 * 参数(callBack)：验证下一个验证规则的回调函数
 * 参数(context)：验证上下文 { r: 验证结果, cfgRules: 实体类验证规则汇总, model: 实体类实例 };
 */
ModuleValidate.prototype.IteratorValidateRule = function (i, callback, v, context) {
    var ignores = context.ignores;
    //如果是存在忽略的校验规则
    if (ignores.indexOf(i) > -1) {
        callback();
    } else {
        this.ValidateRule(v, context.rules[i], i, context.element, callback, context);
    }
}
/*
 * 名称：获取一个自身调用的闭包函数
 * 参数(fn)：待调用函数
 * 参数(arg1-argN)：在调用fn函数时默认传递的参数
 */
ModuleValidate.prototype.GetCall = function (fn, arg1, arg2, argN) {
    var self = this;
    var args = Array.prototype.splice.call(arguments, 1);
    return function () {
        var args2 = Array.prototype.splice.call(arguments, 0);
        args2 = args2.concat(args);
        self.Apply(fn, args2);
    }
}
/*
 * 名称：将指定函数交给当前实例调用
 * 参数(fn)：待调用的函数
 * 参数(args)：参数数组 例如:[1,'name',true] 那么相当于 fn(1,'name',true);
 */
ModuleValidate.prototype.Apply = function (fn, args) {
    if (this.Q.isFunction(fn)) {
        return fn.apply(this, args);
    }
}
/*
 * 名称：获取一个验证结果对象
 * 参数(valid)：初始化的验证结果
 * 参数(message)：初始化的验证结果消息
 */
ModuleValidate.prototype.GetEmptyResult = function (valid, message) {
    return this.F.GetEmptyResult(valid, message);
}

//获取指定实体类的校验规则
function GetObjectRules(name) {
    return require(pathUtil.join(PATH, name + '.validate.js'));
}