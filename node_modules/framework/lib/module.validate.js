/*********************************************************
 * 名称：模块校验工具
 * 描述：主要用于校验指定实体类或者指定html元素的表单元素
 *       并且提供相关ui样式 可以自行更改样式已针对页面风格
 * *******************************************************/

var jQuery = require('jquery');
var pathUtil = require('path');

var PATH = "";
var SELECTORS = "input,select,textarea";
var NOTSELECTORS = "input[type=button],input[type=submit],input[type=hidden],input[type=image]";

var ModuleValidate = function () { }
module.exports = ModuleValidate;

//实体类校验工厂
ModuleValidate.prototype.F = require('./module.validator.js');
//通用处理工具
ModuleValidate.prototype.U = require('./util.js');
//类型检测工具
ModuleValidate.prototype.Q = require('./check.js');
//控制流工具
ModuleValidate.prototype.S = require('async');

//设置实体类库环境目录
ModuleValidate.SetEnviroment = function (path) {
    PATH = path;
}
//校验传入实例
ModuleValidate.prototype.ValidateModel = function (model, name, callBack) {
    var keys = this.U.GetKeys(model);
    var context = { r: this.GetEmptyResult(true), cfgRules: GetObjectRules(name), model: model };
    this.S.eachSeries(keys, this.GetCall(this.IteratorValidateAttribute, context), function (err) { if (typeof (callBack) == 'function') { callBack(context.r); } });
    return context.r;
}
//验证指定表单
ModuleValidate.prototype.ValidateForm = function (selector, name, callBack) {
   //可以讲表单序列化 然后调用ValidateModel
}
//注册表单验证
ModuleValidate.prototype.RegistValidateForm = function (selector, name) {
    var container = jQuery(selector);
    if (container.length <= 0) {
        return;
    }
    var cfgRules = GetObjectRules(name);
    var self = this;
    //当容器中表单失去焦点
    container.bind('blur', function (ev) {
        var target = self.IsForms((ev.srcElement || ev.target));
        if (target) {
            var name = target.attr("name");
            var attrRules = cfgRules[name];
            var context = { r: self.GetEmptyResult(true) };
            var r = self.ValidateAttribute(target.val(), attrRules, target, function () { self.OnFormsBlurAndValidated(target, r); }, context);
        }
    });
    //当容器中表单获取焦点
    container.bind('focus', function (ev) {
        var target = self.IsForms((ev.srcElement || ev.target));
        if (target) {
            self.OnFormsFocus(target);
        }
    });
}
//表单元素获取焦点事件
ModuleValidate.prototype.OnFormsFocus = function (target) {
    target.removeClass("invalidtion").addClass("focusing");
}
//表单元素市区焦点并且验证完毕
ModuleValidate.prototype.OnFormsBlurAndValidated = function (target, r) {
    if (!r.valid) {
        target.removeClass("focusing").removeClass("availability").addClass("invalidtion");
    } else {
        target.removeClass("focusing").removeClass("invalidtion").addClass("availability");
    }
}
//判断指定元素是否符合表单元素
ModuleValidate.prototype.IsForms = function (e) {
    var target = jQuery(e);
    if (target.is(SELECTORS) && target.not(NOTSELECTORS)) {
        return target;
    } else {
        return null;
    }
}
//根据传入属性验证配置验证属性值
ModuleValidate.prototype.ValidateAttribute = function (v, attrRules, element, callBack, context) {
    var r = null;
    if (attrRules) {
        r = context.r;
        //1.无论如何首先校验非空验证
        attrRules.required && (r = context.r = this.ValidateRule(v, attrRules.required, 'required', element, null, context));
        //2.校验其他规则
        r.valid && this.ValidateRules(v, attrRules, 'required', element, callBack, context);
    }
    //如果不需要验证或者 非空校验结果为false
    if (r == null || !r.valid) {
        callBack(r);
    }
}
//根据传入的规则键值列表进行批量验证
ModuleValidate.prototype.ValidateRules = function (v, rules, ignores, element, callBack, context) {
    ignores = this.U.EnsureArray(ignores);
    if (this.Q.isObject(rules)) {
        var keys = this.U.GetKeys(rules);
        context.rules = rules;
        context.element = element;
        context.ignores = ignores;
        this.S.eachSeries(keys, this.GetCall(this.IteratorValidateRule, v, context), this.GetCall(this.SeriesFinal, callBack, context));
    } else {
        callBack();
    }
}
//根据传入指定规则验证指定属性值
ModuleValidate.prototype.ValidateRule = function (v, rule, name, element, callback, rContext) {
    var validator = this.F.GetValidator(name);
    var paras = [];
    if (!this.Q.isObject(rule)) {
        paras.push.apply(paras, this.U.EnsureArray(rule));
        rule = {};
    }
    var context = { rule: rule, paras: paras };
    return validator.Validate(v, element, context, this.GetCall(this.ValidateRuleFinal, callback, rContext));
}
//控制流函数：校验指定规则完毕
ModuleValidate.prototype.ValidateRuleFinal = function (r, callback, context) {
    context.r = r;
    if (this.Q.isFunction(callback)) {
        if (!r.valid) {
            callback(r);
        } else {
            callback();
        }
    }
}
//控制流函数:异步验证指定属性规则
ModuleValidate.prototype.IteratorValidateAttribute = function (i, callBack, context) {
    var cfgRules = context.cfgRules;
    var model = context.model;
    this.ValidateAttribute(model[i], cfgRules[i], null, callBack, context);
}
//控制流函数：自动校准最终回调函数
ModuleValidate.prototype.SeriesFinal = function (err, fn, context) {
    if (!context.r.valid) {
        fn(context);
    } else {
        fn();
    }
}
//控制流函数:异步校验指定规则
ModuleValidate.prototype.IteratorValidateRule = function (i, callback, v, context) {
    var ignores = context.ignores;
    //如果是存在忽略的校验规则
    if (ignores.indexOf(i) > -1) {
        callback();
    } else {
        this.ValidateRule(v, context.rules[i], i, context.element, callback, context);
    }
}
//获取一个自身调用的闭包函数
ModuleValidate.prototype.GetCall = function (fn, arg1, arg2, argN) {
    var self = this;
    var args = Array.prototype.splice.call(arguments, 1);
    return function () {
        var args2 = Array.prototype.splice.call(arguments, 0);
        args2 = args2.concat(args);
        self.Apply(fn, args2);
    }
}
//将传入函数交给当前实例调用
ModuleValidate.prototype.Apply = function (fn, args) {
    if (this.Q.isFunction(fn)) {
        return fn.apply(this, args);
    }
}
ModuleValidate.prototype.GetEmptyResult = function (valid, message) {
    return this.F.GetEmptyResult(valid, message);
}

//获取指定实体类的校验规则
function GetObjectRules(name) {
    return require(pathUtil.join(PATH, name + '.validator.js'));
}